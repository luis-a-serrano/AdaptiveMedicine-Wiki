The Experiments Framework is a framework as a service (FaaS) that uses digital signal processing models on a data object that is periodically producing new signals. These signals are consumed by multiple adaptive filters with potentially different configurations. Each adaptive filter can differ from the others with regards to the employed algorithm or the order of the model. The set of adaptive filters is repeated for each data object since they are exclusive to a data object. Because of that, adaptive filters from data objects that are *similar* might decide to cooperate with each other. During cooperation they share their values for the parameters used on the adaptive algorithm and take into consideration the values from their neighbors. Then the updated parameters are used to make predictions for upcoming signals. These predictions can be used in many ways, of particular interest is for control systems that act upon the data object in order to influence the signals obtained from them.

## Technologies
Microsoft's Azure Service Fabric<sup>[1]</sup> is a distributed systems platform that simplifies the process of developing and managing cloud applications. In particular, it takes care of scalability and reliability by providing a runtime of distributed, stateful and stateless microservices that run at high density on a shared pool of machines<sup>[2]</sup>. Service Fabric provides the Reliable Actors application framework, which is based on the Virtual Actor<sup>[3]</sup> pattern. An actor is a computational unit with single threaded execution that manages it's own state. Multiple actors can execute simultaneously and independently of each other, only interacting with each other by sending asynchronous messages<sup>[4]</sup>. In the Reliable Actors application framework the *virtual* actors also have perpetual existence, automatic instantiation and local transparency. These features simplify the application by doing away with most of the grievances that come from managing the actors lyfecycle.

The main programming language used for Service Fabric is C#, a multi-paradigm language that support object-oriented practices and has automatic garbage collection. Both of these features complement the focus of service fabric by promoting a higher productivity and ensuring program integrity.

[1]: https://azure.microsoft.com/services/service-fabric/ "Azure Service Fabric"
[2]: https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview "Overview of Azure Service Fabric"
[3]: https://www.microsoft.com/en-us/research/publication/orleans-distributed-virtual-actors-for-programmability-and-scalability/ "Orleans: Distributed Virtual Actors for Programmability and Scalability"
[4]: https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-actors-introduction "Introduction to Service Fabric Reliable Actors"

## Implementation
The following is a rough diagram of how the actors pattern is used on the Experiments Framework.

| ![Experiments Framework Actor Pattern](images/ExperimentsFrameworkActorPattern.png) |
| --- |
| A box with round corners represents an *actor type*, while a circle represents an *actor instance* (or simply *actor*/*instance*). All instances from the same type share the same code, however each one has their own state (and thus can behave differently). Each arrow represents a *message* being sent between actors and the color gives a hint of the context. Blue arrows are tied to a particular experiment, red arrows are tied to a particular participant, and yellow arrows are tied to both a particular experiment and participant. For convenience, all the actors tied to the same experiment and participant are grouped on the diagram inside a box with dotted outline. This grouping will repeat indefinitely for each participant added to an experiment. |

### Experiment Manager and Data Manager Actor Types
An *Experiment Manager* actor instance is in charge of the configuration details for all the actors tied to it as well as relaying meta actions that are pertinent to the experiment as a whole. A *Data Manager* actor instance is in charge of all the data owned by a potential participant. The above diagram shows that an experiment has already been designed (represented by an actor instance already existing inside the Experiment Manager actor type), and that a potential participant already exists (represented by an actor instance already existing inside the Data Manager actor type). At some point the potential participant decides to be part of the experiment and talks to a specific experiment manager instance (the interaction is not shown on the diagram). This actor then creates new instances for the actor types *Model Manager*, *Network Manager* and *Performance Manager*. At this point the newly created instances are tied to the experiment that created them and the participant that was added.

### Model Manager Actor Type
A Model Manager actor instance is in charge of all the models that must run for a specific experiment and participant. By using the configuration details received from the experiment actor a number of actor instances will be created on potentially multiple *Algorithm* actor types. A reference to these new instances are recorded inside the model manager actor. Also, the model manager subscribes to the data manager that it's tied to for any data pertinent to the tied experiment. Whenever new data is received from the data manager, this is relayed to all the previously saved algorithm actors.

### Algorithm Actor Type
There can be multiple Algorithm actor types that can be used, each one representing a different computational algorithm. An Algorithm actor instance is in charge of the data that it needs to run and the parameters that it calculates during each run. By using the configuration details received from the model manager actor it initializes the values for the parameters. Occasionally the actor will receive new data to process. When this happens the new data is saved, the parameters are recalculated, saved and forwarded to the network manager actor. Later on that same network manager actor will send back the parameters from all the neighbors so that they can be used on the next processing event. Before that happens, the recalculated parameters are used to predict the next value. This value is then sent to the performance manager actor for further analysis of all the different models.

### Network Manager Actor Type
A Network Manager actor instance is in charge of synchronizing all the communications between algorithms of the same *flavor* (actor type and *order*) from different participants that are part of the tied experiment. The amount of neighbors per algorithm flavor to whom data is shared is determined by the configuration details received from the experiment actor. The synchronization is achieved by interacting with the network manager instances that manage other participants and that are tied to the same experiment. Whenever all the data is collected this information is sent to the appropriate algorithm actor to prepare it for the next iteration of data processing.

### Performance Manager Actor Type
A Performance Manager actor instance is in charge of analyzing the calculations produced by the different models. Each algorithm flavor (or model) reports their new prediction for each data processing event and this value is stored and compared to the others.